// Professional PDF Generator for Nigerian Legal Documents
import { PDFDocument, PDFPage, rgb, StandardFonts, PageSizes } from 'pdf-lib';
import { documentLogger } from '@/utils/logger';
import { GeneratedDocument, DocumentType } from '@/types';

interface PDFGenerationOptions {
  format: 'legal' | 'standard' | 'compact';
  watermark?: string;
  includeSignatureLines?: boolean;
  includeNotarization?: boolean;
  includeStampArea?: boolean;
  fontSize?: number;
  lineSpacing?: number;
  margins?: {
    top: number;
    bottom: number;
    left: number;
    right: number;
  };
  footerText?: string;
  headerText?: string;
}

interface DocumentSection {
  title?: string;
  content: string;
  fontSize?: number;
  bold?: boolean;
  centered?: boolean;
  pageBreakBefore?: boolean;
  marginTop?: number;
  marginBottom?: number;
}

interface SignatureLine {
  label: string;
  width: number;
  position: { x: number; y: number };
  includeDate?: boolean;
  includePrint?: boolean;
}

export class PDFGenerator {
  private static readonly DEFAULT_OPTIONS: PDFGenerationOptions = {
    format: 'legal',
    fontSize: 12,
    lineSpacing: 1.5,
    margins: {
      top: 72,    // 1 inch
      bottom: 72, // 1 inch
      left: 72,   // 1 inch
      right: 72,  // 1 inch
    },
  };

  private static readonly NIGERIAN_LEGAL_FORMATTING = {
    titleFontSize: 16,
    headingFontSize: 14,
    bodyFontSize: 12,
    footnoteFontSize: 10,
    lineHeight: 1.5,
    paragraphSpacing: 12,
    sectionSpacing: 18,
  };

  /**
   * Generate professional PDF for legal document
   */
  async generatePDF(
    document: GeneratedDocument,
    options: Partial<PDFGenerationOptions> = {}
  ): Promise<Buffer> {
    try {
      const opts = { ...PDFGenerator.DEFAULT_OPTIONS, ...options };
      
      documentLogger.info('Starting PDF generation', {
        documentId: document.id,
        documentType: document.documentType,
        format: opts.format,
      });

      // Create PDF document
      const pdfDoc = await PDFDocument.create();
      
      // Set document metadata
      pdfDoc.setTitle(document.title);
      pdfDoc.setSubject(`${document.documentType} - Generated by MISS Legal AI`);
      pdfDoc.setAuthor('MISS Legal AI');
      pdfDoc.setCreator('MISS Legal AI - Nigerian Legal Assistant');
      pdfDoc.setCreationDate(new Date());
      pdfDoc.setModificationDate(new Date());

      // Embed fonts
      const regularFont = await pdfDoc.embedFont(StandardFonts.TimesRoman);
      const boldFont = await pdfDoc.embedFont(StandardFonts.TimesRomanBold);
      const italicFont = await pdfDoc.embedFont(StandardFonts.TimesRomanItalic);

      // Parse document content into sections
      const sections = this.parseDocumentContent(document.content, document.documentType);

      // Generate pages
      let currentPage = pdfDoc.addPage(PageSizes.A4);
      let currentY = PageSizes.A4[1] - opts.margins!.top;

      // Add header if specified
      if (opts.headerText) {
        currentY = await this.addHeader(currentPage, opts.headerText, regularFont, opts, currentY);
      }

      // Add document title
      currentY = await this.addDocumentTitle(
        currentPage,
        document.title,
        boldFont,
        opts,
        currentY
      );

      // Add content sections
      for (const section of sections) {
        const result = await this.addSection(
          pdfDoc,
          currentPage,
          section,
          regularFont,
          boldFont,
          opts,
          currentY
        );
        
        currentPage = result.page;
        currentY = result.y;
      }

      // Add signature lines if required
      if (opts.includeSignatureLines) {
        const result = await this.addSignatureSection(
          pdfDoc,
          currentPage,
          document.documentType,
          regularFont,
          opts,
          currentY
        );
        currentPage = result.page;
        currentY = result.y;
      }

      // Add notarization section if required
      if (opts.includeNotarization) {
        const result = await this.addNotarizationSection(
          pdfDoc,
          currentPage,
          regularFont,
          boldFont,
          opts,
          currentY
        );
        currentPage = result.page;
        currentY = result.y;
      }

      // Add stamp duty area if required
      if (opts.includeStampArea) {
        await this.addStampDutyArea(currentPage, opts);
      }

      // Add watermark if specified
      if (opts.watermark) {
        await this.addWatermark(pdfDoc, opts.watermark, regularFont);
      }

      // Add footer to all pages
      if (opts.footerText) {
        await this.addFooterToAllPages(pdfDoc, opts.footerText, regularFont, opts);
      }

      // Add page numbers
      await this.addPageNumbers(pdfDoc, regularFont, opts);

      // Add legal disclaimer
      await this.addLegalDisclaimer(pdfDoc, regularFont, opts);

      // Generate final PDF buffer
      const pdfBytes = await pdfDoc.save();
      
      documentLogger.info('PDF generation completed', {
        documentId: document.id,
        pdfSize: pdfBytes.length,
        pageCount: pdfDoc.getPageCount(),
      });

      return Buffer.from(pdfBytes);
    } catch (error) {
      documentLogger.error('PDF generation failed', {
        documentId: document.id,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Generate Word document (DOCX) for editing
   */
  async generateWordDocument(document: GeneratedDocument): Promise<Buffer> {
    try {
      // This would integrate with a library like 'docx' to generate Word documents
      // For now, we'll create a simple text-based representation
      
      const wordContent = this.generateWordContent(document);
      return Buffer.from(wordContent, 'utf-8');
    } catch (error) {
      documentLogger.error('Word document generation failed', {
        documentId: document.id,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Generate document preview image
   */
  async generatePreviewImage(document: GeneratedDocument): Promise<Buffer> {
    try {
      // Generate a PNG preview of the first page
      const pdfBuffer = await this.generatePDF(document, {
        format: 'compact',
        watermark: 'PREVIEW',
      });

      // This would use a library like 'pdf2pic' to convert PDF to image
      // For now, return the PDF buffer (frontend can handle PDF preview)
      return pdfBuffer;
    } catch (error) {
      documentLogger.error('Preview generation failed', {
        documentId: document.id,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  // Private helper methods

  private parseDocumentContent(content: string, documentType: DocumentType): DocumentSection[] {
    const sections: DocumentSection[] = [];
    
    // Split content by paragraphs and identify sections
    const paragraphs = content.split('\n\n').filter(p => p.trim());
    
    for (const paragraph of paragraphs) {
      const trimmed = paragraph.trim();
      
      // Check if it's a title/heading (all caps or starts with number)
      if (this.isHeading(trimmed)) {
        sections.push({
          title: trimmed,
          content: '',
          bold: true,
          centered: this.isCenteredHeading(trimmed),
          fontSize: PDFGenerator.NIGERIAN_LEGAL_FORMATTING.headingFontSize,
          marginTop: 18,
          marginBottom: 12,
        });
      } else {
        sections.push({
          content: trimmed,
          fontSize: PDFGenerator.NIGERIAN_LEGAL_FORMATTING.bodyFontSize,
          marginBottom: 12,
        });
      }
    }

    return sections;
  }

  private isHeading(text: string): boolean {
    // Check if text is likely a heading
    return (
      text === text.toUpperCase() && text.length < 100 ||
      /^\d+\./.test(text) ||
      text.startsWith('WHEREAS') ||
      text.startsWith('NOW THEREFORE') ||
      text.startsWith('IN WITNESS WHEREOF')
    );
  }

  private isCenteredHeading(text: string): boolean {
    const centeredPatterns = [
      'TENANCY AGREEMENT',
      'AFFIDAVIT',
      'POWER OF ATTORNEY',
      'AGREEMENT',
      'CONTRACT',
    ];

    return centeredPatterns.some(pattern => text.includes(pattern));
  }

  private async addHeader(
    page: PDFPage,
    headerText: string,
    font: any,
    options: PDFGenerationOptions,
    currentY: number
  ): Promise<number> {
    const { width } = page.getSize();
    const textWidth = font.widthOfTextAtSize(headerText, 10);
    
    page.drawText(headerText, {
      x: (width - textWidth) / 2,
      y: currentY,
      size: 10,
      font,
      color: rgb(0.5, 0.5, 0.5),
    });

    return currentY - 30;
  }

  private async addDocumentTitle(
    page: PDFPage,
    title: string,
    font: any,
    options: PDFGenerationOptions,
    currentY: number
  ): Promise<number> {
    const { width } = page.getSize();
    const fontSize = PDFGenerator.NIGERIAN_LEGAL_FORMATTING.titleFontSize;
    const textWidth = font.widthOfTextAtSize(title, fontSize);
    
    page.drawText(title, {
      x: (width - textWidth) / 2,
      y: currentY,
      size: fontSize,
      font,
      color: rgb(0, 0, 0),
    });

    return currentY - (fontSize * 2);
  }

  private async addSection(
    pdfDoc: PDFDocument,
    currentPage: PDFPage,
    section: DocumentSection,
    regularFont: any,
    boldFont: any,
    options: PDFGenerationOptions,
    currentY: number
  ): Promise<{ page: PDFPage; y: number }> {
    let page = currentPage;
    let y = currentY;

    // Add margin top if specified
    if (section.marginTop) {
      y -= section.marginTop;
    }

    // Check if we need a new page
    if (section.pageBreakBefore || y < options.margins!.bottom + 100) {
      page = pdfDoc.addPage(PageSizes.A4);
      y = PageSizes.A4[1] - options.margins!.top;
    }

    const font = section.bold ? boldFont : regularFont;
    const fontSize = section.fontSize || options.fontSize!;
    const { width } = page.getSize();
    const textWidth = width - options.margins!.left - options.margins!.right;

    // Handle title
    if (section.title) {
      const lines = this.wrapText(section.title, font, fontSize, textWidth);
      for (const line of lines) {
        const lineWidth = font.widthOfTextAtSize(line, fontSize);
        const x = section.centered ? 
          (width - lineWidth) / 2 : 
          options.margins!.left;

        page.drawText(line, {
          x,
          y,
          size: fontSize,
          font,
          color: rgb(0, 0, 0),
        });

        y -= fontSize * (options.lineSpacing || 1.5);
      }
    }

    // Handle content
    if (section.content) {
      const lines = this.wrapText(section.content, font, fontSize, textWidth);
      for (const line of lines) {
        // Check if we need a new page
        if (y < options.margins!.bottom + fontSize) {
          page = pdfDoc.addPage(PageSizes.A4);
          y = PageSizes.A4[1] - options.margins!.top;
        }

        const lineWidth = font.widthOfTextAtSize(line, fontSize);
        const x = section.centered ? 
          (width - lineWidth) / 2 : 
          options.margins!.left;

        page.drawText(line, {
          x,
          y,
          size: fontSize,
          font,
          color: rgb(0, 0, 0),
        });

        y -= fontSize * (options.lineSpacing || 1.5);
      }
    }

    // Add margin bottom if specified
    if (section.marginBottom) {
      y -= section.marginBottom;
    }

    return { page, y };
  }

  private async addSignatureSection(
    pdfDoc: PDFDocument,
    currentPage: PDFPage,
    documentType: DocumentType,
    font: any,
    options: PDFGenerationOptions,
    currentY: number
  ): Promise<{ page: PDFPage; y: number }> {
    let page = currentPage;
    let y = currentY - 50; // Add some space before signatures

    const signatureLines = this.getSignatureLines(documentType);
    
    // Check if we need a new page for signatures
    const requiredHeight = signatureLines.length * 80 + 100;
    if (y < options.margins!.bottom + requiredHeight) {
      page = pdfDoc.addPage(PageSizes.A4);
      y = PageSizes.A4[1] - options.margins!.top - 50;
    }

    for (const signatureLine of signatureLines) {
      // Draw signature line
      page.drawLine({
        start: { x: signatureLine.position.x, y },
        end: { x: signatureLine.position.x + signatureLine.width, y },
        thickness: 1,
        color: rgb(0, 0, 0),
      });

      // Draw label below line
      page.drawText(signatureLine.label, {
        x: signatureLine.position.x,
        y: y - 15,
        size: 10,
        font,
        color: rgb(0, 0, 0),
      });

      // Add date line if required
      if (signatureLine.includeDate) {
        const dateX = signatureLine.position.x + signatureLine.width + 50;
        page.drawLine({
          start: { x: dateX, y },
          end: { x: dateX + 100, y },
          thickness: 1,
          color: rgb(0, 0, 0),
        });

        page.drawText('DATE', {
          x: dateX + 35,
          y: y - 15,
          size: 10,
          font,
          color: rgb(0, 0, 0),
        });
      }

      y -= 60;
    }

    return { page, y };
  }

  private async addNotarizationSection(
    pdfDoc: PDFDocument,
    currentPage: PDFPage,
    regularFont: any,
    boldFont: any,
    options: PDFGenerationOptions,
    currentY: number
  ): Promise<{ page: PDFPage; y: number }> {
    let page = currentPage;
    let y = currentY - 50;

    // Check if we need a new page
    if (y < options.margins!.bottom + 200) {
      page = pdfDoc.addPage(PageSizes.A4);
      y = PageSizes.A4[1] - options.margins!.top - 50;
    }

    const { width } = page.getSize();

    // Notarization title
    const title = 'NOTARIZATION';
    const titleWidth = boldFont.widthOfTextAtSize(title, 14);
    page.drawText(title, {
      x: (width - titleWidth) / 2,
      y,
      size: 14,
      font: boldFont,
      color: rgb(0, 0, 0),
    });

    y -= 30;

    // Notarization text
    const notaryText = [
      'Before me, the undersigned authority, personally appeared the above-named',
      'person(s), who proved to me on the basis of satisfactory evidence to be',
      'the person(s) whose name(s) is/are subscribed to the within instrument',
      'and acknowledged to me that he/she/they executed the same in his/her/their',
      'authorized capacity, and that by his/her/their signature(s) on the instrument',
      'the person(s), or the entity upon behalf of which the person(s) acted,',
      'executed the instrument.',
    ];

    for (const line of notaryText) {
      page.drawText(line, {
        x: options.margins!.left,
        y,
        size: 10,
        font: regularFont,
        color: rgb(0, 0, 0),
      });
      y -= 15;
    }

    y -= 20;

    // Notary signature line
    page.drawLine({
      start: { x: options.margins!.left, y },
      end: { x: options.margins!.left + 300, y },
      thickness: 1,
      color: rgb(0, 0, 0),
    });

    page.drawText('NOTARY PUBLIC / COMMISSIONER FOR OATHS', {
      x: options.margins!.left,
      y: y - 15,
      size: 10,
      font: regularFont,
      color: rgb(0, 0, 0),
    });

    // Seal area
    page.drawRectangle({
      x: width - options.margins!.right - 150,
      y: y - 80,
      width: 120,
      height: 80,
      borderColor: rgb(0, 0, 0),
      borderWidth: 1,
    });

    page.drawText('(OFFICIAL SEAL)', {
      x: width - options.margins!.right - 130,
      y: y - 45,
      size: 10,
      font: regularFont,
      color: rgb(0, 0, 0),
    });

    return { page, y: y - 100 };
  }

  private async addStampDutyArea(page: PDFPage, options: PDFGenerationOptions): Promise<void> {
    const { width, height } = page.getSize();
    
    // Add stamp duty box in top right corner
    page.drawRectangle({
      x: width - options.margins!.right - 150,
      y: height - options.margins!.top - 100,
      width: 120,
      height: 80,
      borderColor: rgb(0, 0, 0),
      borderWidth: 2,
    });

    page.drawText('STAMP DUTY', {
      x: width - options.margins!.right - 130,
      y: height - options.margins!.top - 50,
      size: 10,
      font: await PDFDocument.create().then(doc => doc.embedFont(StandardFonts.HelveticaBold)),
      color: rgb(0, 0, 0),
    });
  }

  private async addWatermark(pdfDoc: PDFDocument, watermark: string, font: any): Promise<void> {
    const pages = pdfDoc.getPages();
    
    for (const page of pages) {
      const { width, height } = page.getSize();
      
      // Calculate diagonal position for watermark
      const centerX = width / 2;
      const centerY = height / 2;
      
      page.drawText(watermark, {
        x: centerX - 100,
        y: centerY,
        size: 72,
        font,
        color: rgb(0.9, 0.9, 0.9),
        rotate: { type: 'degrees', angle: -45 },
      });
    }
  }

  private async addFooterToAllPages(
    pdfDoc: PDFDocument,
    footerText: string,
    font: any,
    options: PDFGenerationOptions
  ): Promise<void> {
    const pages = pdfDoc.getPages();
    
    for (const page of pages) {
      const { width } = page.getSize();
      const textWidth = font.widthOfTextAtSize(footerText, 8);
      
      page.drawText(footerText, {
        x: (width - textWidth) / 2,
        y: options.margins!.bottom / 2,
        size: 8,
        font,
        color: rgb(0.5, 0.5, 0.5),
      });
    }
  }

  private async addPageNumbers(pdfDoc: PDFDocument, font: any, options: PDFGenerationOptions): Promise<void> {
    const pages = pdfDoc.getPages();
    const totalPages = pages.length;
    
    pages.forEach((page, index) => {
      const { width } = page.getSize();
      const pageText = `Page ${index + 1} of ${totalPages}`;
      const textWidth = font.widthOfTextAtSize(pageText, 10);
      
      page.drawText(pageText, {
        x: width - options.margins!.right - textWidth,
        y: options.margins!.bottom / 2,
        size: 10,
        font,
        color: rgb(0.5, 0.5, 0.5),
      });
    });
  }

  private async addLegalDisclaimer(pdfDoc: PDFDocument, font: any, options: PDFGenerationOptions): Promise<void> {
    const lastPage = pdfDoc.getPages()[pdfDoc.getPageCount() - 1];
    const { width } = lastPage.getSize();
    
    const disclaimer = 'This document was generated by MISS Legal AI. Please consult with a qualified Nigerian lawyer for legal advice.';
    const textWidth = font.widthOfTextAtSize(disclaimer, 8);
    
    lastPage.drawText(disclaimer, {
      x: (width - textWidth) / 2,
      y: 30,
      size: 8,
      font,
      color: rgb(0.6, 0.6, 0.6),
    });
  }

  private wrapText(text: string, font: any, fontSize: number, maxWidth: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';

    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const testWidth = font.widthOfTextAtSize(testLine, fontSize);
      
      if (testWidth <= maxWidth) {
        currentLine = testLine;
      } else {
        if (currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          // Word is too long, force it on a line
          lines.push(word);
        }
      }
    }
    
    if (currentLine) {
      lines.push(currentLine);
    }

    return lines;
  }

  private getSignatureLines(documentType: DocumentType): SignatureLine[] {
    const signatureConfigs: Record<DocumentType, SignatureLine[]> = {
      'tenancy_agreement': [
        {
          label: 'LANDLORD',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
        {
          label: 'TENANT',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
        {
          label: 'WITNESS 1',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
        {
          label: 'WITNESS 2',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
      ],
      'affidavit': [
        {
          label: 'DEPONENT',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: false,
        },
      ],
      'power_of_attorney': [
        {
          label: 'PRINCIPAL/GRANTOR',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
        {
          label: 'WITNESS 1',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
        {
          label: 'WITNESS 2',
          width: 200,
          position: { x: 72, y: 0 },
          includeDate: true,
        },
      ],
    };

    return signatureConfigs[documentType] || [];
  }

  private generateWordContent(document: GeneratedDocument): string {
    // Generate a Word-compatible format (simplified)
    const content = `
${document.title}

Generated by MISS Legal AI
Document Type: ${document.documentType}
Language: ${document.language}
State: ${document.state}
Created: ${new Date(document.createdAt).toLocaleDateString()}

---

${document.content}

---

LEGAL DISCLAIMER:
This document was generated by an AI system and should be reviewed by a qualified Nigerian lawyer before use in any legal proceedings. The accuracy and completeness of this document cannot be guaranteed.

Generated by MISS Legal AI - Nigerian Legal Assistant
© ${new Date().getFullYear()} ODIA Intelligence + Mudiame University
`;

    return content;
  }
}

export default PDFGenerator;
